class Solution {
public:
    
    struct dsu{
        private:
        vector <int> _parent, _size;
        
        public:
        dsu(int n ){
            _parent.resize(n,0);
            for( int i = 0 ; i < n ; i++) 
                _parent[i] = i;
            _size.resize(n,1);
        }
        
        int ufind( int x){
            if( _parent[x] == x )
                return x;
            return _parent[x] = ufind(_parent[x]);
        }
        
        void uunion(int a, int b){
            
            a = ufind(a) , b = ufind(b);
            if( a == b )
                return;
            
            if( b > a )
                swap(a,b);
            
            _parent[b] = a;
            _size[a] += _size[b];
            
        }
        
        int getCompSize(int x){
            x = ufind(x);
            return _size[x];
        }
        
    };
    
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        
        int n = graph.size();
        dsu conn(n);
        sort( initial.begin(), initial.end());
        
        for( int i = 0 ; i < n ; i++){
            for( int j = 0 ; j < n ; j++){
                if( j != i and graph[i][j] == 1 )
                    conn.uunion(i,j);
            }
        }
        
        unordered_map <int, int> malSz;
        
        for( int node : initial ) {
            int par = conn.ufind(node);
            malSz[par]++;
        }
        
        
        int maxRemoval = -1 , ans = -1;
        
        for( int node : initial ){
            int removal = 0, par = conn.ufind(node);
            
            if( malSz[par] == 1 ) {
                removal = conn.getCompSize(par);
            }
            
            if( removal > maxRemoval ){
                maxRemoval = removal,
                ans = node;
            }
            
        }
        
        return ans;
    }
};